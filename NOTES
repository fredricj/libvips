This branch adds chunked write for JXL save.

It uses the old write by default, but the `chunked` flag enables a new chunked
write path.

- we should removed the old sequential write once we're done
- need v0.11 at minimum (v0.9 does not demand data in small chunks)

## sequential write

- start sink_disc to generate scanlines, accumulate to a 2100 scanline
  buffer

	we know the first set of tiles will start at y == 0, so we don't
	need to wait for data_at()
VipsSemaphone tiles_available
VipsSemaphone frame_complete
VipsSemaphone tiles_written
VipsSemaphone write_complete

	need something like vips_semaphore_up_all()

- scanlines come into the BG writer

	- add to current write buffer

	- have min(page_height, 2064) scanlines?

- as soon as we have the next min(remaining page height, 2064) scanlines we
  can write another line of tiles

	- start a frame encode thread if we don't have one

	- up on tiles_available

		there can be many threads waiting in data_at(), we'll need to
		up a lot

		frame encode thread now encodes a line of tiles, then resets
		scanline_buffer ready for the next set

	- is this the final line of tiles?

		- down on frame_complete ... ie. exit of the frame encode thread

		- reset scanline_buffer for next frame

	- frame not complete?

		- down on tiles_written

			data_at() has adjusted scanline_buffer ready for the
			next set of tiles

- frame encode thread:

	- make the frame settings, set up stuff

	- call JxlEncoderAddChunkedFrame() and block

	- the call returns and the frame has been written

	- signal on sem frame_complete

	- return

- in data_at() we need to:

	- old scanlines? error

	- next set of scanlines?

		- down on write_complete

			many data_at() will restart, we'll need a mutex

			or maybe buffer_release can just up one and release a
			single thread? that thread could move scanline_buffer,
			then restart the rest?

		- find new top of scanline_bytes ... there can be a 16 pixel
		  overlap, and we'll need to copy some amount of pixels from
		  the end to the start, and set scanline_y correctly

		- up on tiles_written

			sink_disc now fills data for the next set of tiles

		- down on tiles_available

		- and fall through to the case below

	- in the current set of scanlines?

		- add to n_threads, a counter tracking the number of threads
		  running on this memory

		- return a pointer into the memory

- buffer_release

	- decrement n_threads, hits zero?

		- up on sem write_complete

			** many threads can be blocked, we'll need to up a lot

